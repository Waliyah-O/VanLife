a route/url is a portion of our route path that is a placeholder for what will eventually be the actual segment in the url of the page.

NESTING <ROUTE>

		<Route path="vans">
            <Route index element={<Vans />} />
            <Route path=":id" element={<VanDetail />} />
        </Route>

	1. Can use either <Route/> or <Route>...</Route>
	2. when you want to keep displaying some UI on the page, but also want to display more
	3. When you want to avoid repetition in your route paths


1. What is the primary reason to use a nested route?
Whenever we have some shared UI between routes in our app.

2. What is a layout route?
It's the parent route of some nested routes that contains just the portion of the UI that will be shared. It will use an Outlet components

3. What does an <Outlet/> component do and when do you use it?
We use it anytime we have a parent Route that's wrapping children routes. It renders the matching child route's 'element' prop given its route definition.

A layout route will use an outlet component. The outlet component is used anytime we have a parent route that's wrapping children routes. The outlet is a placeholder that represents the place in your parent route where the child routes will render its content 


/************ INDEX ROUTE *************/
what's an index route? 
It's the 'default route' we want to render when the path of the parent route matches. It gives us a chance to render an element inside the parent's <Outlet/> at the same path as the parent route/



/********** RELATIVE ROUTES *********/
React router incorporated unix change dir cmd cd .. takes you to the parent folder, cd . leaves you on the current folder. "." leaves you on the current route, ".." takes you to the parent route


Query Parameters
	1. Represents a change in the UI: 
		a. sorting, filtering, pagination
	2. used as a "single source of truth" for certain application state.
		a. should a user be able to revisit or share this page just like it is? if "yes", then you might consider RAISING THAT STATE UP to the url in a query parameter

		hostIDs
		123
		456
		789


 // to={`/host/vans/${van.id}`}
		<Link to={`/vans/${van.id}`}>Destination</Link> or 
		 <Link to={van.id}>
		




{
  /* <div className="van-list-filter-buttons">
        <button
          className="van-type simple"
          onClick={() => setSearchParams({ type: "simple" })}
        >
          Simple
        </button>
        <button
          className="van-type luxury"
          onClick={() => setSearchParams({ type: "luxury" })}
        >
          luxury
        </button>
        <button
          className="van-type rugged"
          onClick={() => setSearchParams({ type: "rugged" })}
        >
          rugged
        </button>
        <button
          className="van-type clear-filters"
          onClick={() => setSearchParams({})}
        >
          clear filter
        </button>
      </div> */
}

// function genNewSearchParamString(key, value) {
//   const searchParams = new URLSearchParams(searchParams);
//   if (value === null) {
//     searchParams.delete(key);
//   } else {
//     searchParams.set(key, value);
//   }
//  return `?${searchParams.toString()}
// }

{
  /* <Link to={genNewSearchParamString("type", "luxury")}>Luxury</Link>
<Link to={genNewSearchParamString("type", "simple")}>Simple</Link>
<Link to={genNewSearchParamString("type", "rugged")}>Rugged</Link>
<Link to={genNewSearchParamString("type", null)}>Clear</Link> */
}

{
  /* <Link className="van-type simple" to="?type=simple">
          Simple
        </Link>
        <Link className="van-type luxury" to="?type=luxury">
          Luxury
        </Link>
        <Link className="van-type rugged" to="?type=rugged">
          Rugged
        </Link>
        <Link className="van-type clear-filters" to=".">
          Clear
        </Link> */
}

{/* catch all routes, if there are no other routes listed, use <Route path="*"/> element={<h1>Page not found!</h1>} */}

"HAPPY PATH"
    Assumes everything goes according to plan exactly as we hope it does. WHen the dev assumes that the user is going to use the app according to the way the dev expects/wants and everything goes according to plan.
    But,
    It does not account for errors of other problems that could occur when the app is deployed


"SAD PATH"
    Forces us to imagine what could go wrong and plan accordingly.
    things like 
      Error handling, lading states, form validation etc